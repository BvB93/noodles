

#================> Python Standard  and third-party <==========

from importlib import import_module

## ================ FireWorks modules  ==================
from fireworks import FireTaskBase,  Firework, FWorker, PyTask, ScriptTask, WorkFlow
from fireworks.utilities.fw_serializers import FWSerializable

#=================> QMWorkflows module <=================
from qmworks.mongoConfig.remoteMongo import remoteLpad


#==================> Internal modules <==========
from .datamodel import *

#====================<>===============================

def run_fireworks(workflow,z remote_db = 'felipe@145.100.59.99',  queue_type = 'SLURM', walltime ='00:15:00', cpus_per_task = 1, task_per_node = 1, ntasks = 1 ):
    """
    Returns the result of evaluting the worflow using the `Offline <https://pythonhosted.org/FireWorks/offline_tutorial.html?highlight=offline>` mode of fireworks.
 
    :param workflow:  Workflow to compute
    :type  workflow:  namedTuple |Workflow| or |PromisedObject| 
    :param remote_host: Remote platform to run the calculations
    :type  remote_host: string
    """



     ## FireWorks Configuration
    if remote_db:
        launchpad, handlerPort = remoteLpad(remote_db)
    else:
        launchpad = LaunchPad()
    launchpad.reset('', require_password=False)


    #Create WorkFlows
    fireworks_WF       = NoodlesTask(workFlow)
    launchpad.add_wf(fireworks_WF) 

    #Queue  Configuration
    fworker      = FWorker(name="standard_worker")
    queueadapter = create_qadapter(queue, walltime, cpus_per_task, task_per_node)
    = load_object_from_file("/home/fza900/QueueFireworksConfig/qadapter_slurm.yaml")
     
    rapidfire(launchpad, fworker ,queueadapter )
    
    if remote_db:
        handlerPort.kill()    # close connections    


#====================<>===============================
class NoodlesTask(FireTaskBase,FWSerializable):
    """
    Translates the workflows generated by the Engine infrasctructure to a Fireworks Workflow
    """

    _fw_name = "NoodlesTask"
    
    def run_task(self, fw_spec):
        if self.get("use_global_spec"):
            self._load_params(fw_spec)
        else:
            self._load_params(self)

        root_ref, nodes, links = self.workflow

        fireworks, connections = [], {}
        #Root Case
        node1    = nodes[root_ref]
        fun      = fun_node.foo
        var_res  = 'var_{}'.format(root_ref)
        task     = PyTask(node1.foo, args = node1.bound_args.args, kwargs = node1.bound_args.kwargs, stored_data_varname = var_res) 
        fw1      = Firework(task, spec={"_pass_job_info": True}, fw_id = root_ref)
        nodes.pop(root_ref)

        fireworks.append(fw1)
        ## ith-case 


        ##     
        return WorkFlow(fireworks, connections)



        def _load_params(self,d):
        wf             = d['workflow']
        self.workFlow  = get_workflow(wf)

        # optional parameters

    queueadapter = create_qadapter(queue_type, walltime, cpus_per_task, task_per_node)        


def create_addapters(**kwargs):
    """
    """
    queue_type = kwargs['queue_type']
    kwargs.pop('queue')

    kwargs['_fw_name']   = CommondAdapter
    kwargs['_fw_q_type'] = queue_type
    kwargs['job_name']   = 'Noodles'
    kwargs['pre_rocket'] = None
    kwargs['post_rocket']= None


    rocket_launch: rlaunch -w /home/fza900/QueueFireworksConfig/my_fworker.yaml -l /home/fza900/QueueFireworksConfig/my_launchpad.yaml singleshot
queue: null
account: fza900
logdir: path/to/logging

    return load_object(kwargs)



    # def run_task(self, fw_spec):
    #     argkeys      = fw_spec['args']
    #     imports_spec = fw_spec['import_spec']
    #     foo          = fw_spec['function']
    #     args = dict((name, fw_spec[key]) for key, name in argkeys.values())


    #     env = load_environment(import_spec)
    #     result = env.apply_function(foo, args)



        
# class Environment:
#     def __init__(globals = {}, locals = {}):
#         self.globals = globals
#         self.locals = locals

#     def simple_import(module):
#         self.locals[module] = import_module(module)

#     def import_module(module, base, import_as):
#         self.locals[import_as] = import_module(module, base)

#     def from_module_import(module, base, import_dict):
#         tmp = import_module(module, base)
#         for k, v in import_dict.items():
#             self.locals[v] = tmp[k]

#     def apply_function(foo, *args, **kwargs):
#         self.locals['args']   = args
#         self.locals['kwargs'] = kwargs
#         return eval("{foo}(*args, **kwargs)".format(foo = foo),
#             self.globals, self.locals)

# def load_environment(import_spec):
#     env = Environment()
#     for m in import_spec:
#         env.simple_import(m)
#     return env

