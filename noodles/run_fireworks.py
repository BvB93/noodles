

# __all__ = ['run_fireworks', 'NoodleTask']

"""
Notes:
 *
"""

#================> Python Standard  and third-party <==========

from importlib import import_module
import sys
## ================ FireWorks modules  ==================
from fireworks                          import FireTaskBase,  Firework, FWorker, PyTask, ScriptTask, Workflow
from fireworks.queue.queue_launcher     import rapidfire, launch_rocket_to_queue
from fireworks.utilities.fw_serializers import FWSerializable
from fireworks.user_objects.queue_adapters.common_adapter import CommonAdapter
from fireworks.utilities.fw_utilities   import explicit_serialize
#=================> QMWorkflows module <=================
from qmworks.mongoConfig.remoteMongo import remoteLpad


#==================> Internal modules <==========
from .datamodel import *

#====================<>===============================
class UndefinedDependency(Exception):
    def __init__(self, var):
        self.msg = "Variable '{}' is not a regular value, neither has an assoicated workflow".format(var)

    def __str__(self):
        return self.msg 

#====================<>===============================
    
Ref_db = namedtuple('Ref_db',('local_name','db_name'))

#====================<>===============================

#TODO: Remote Queue
def run_fireworks(workflow, remote_db = None,  queue_type = 'SLURM', walltime ='00:15:00', cpus_per_task = 1, task_per_node = 1, ntasks = 1, maxjobs_queue = 10):
    """
    Returns the result of evaluting the worflow using the `Offline <https://pythonhosted.org/FireWorks/offline_tutorial.html?highlight=offline>` mode of fireworks.
 
    :param workflow:  Workflow to compute
    :type  workflow:  namedTuple |Workflow| or |PromisedObject| 
    :param remote_host: Remote platform to run the calculations
    :type  remote_host: string
    """


     ## FireWorks Configuration
    if remote_db:
        launchpad, handlerPort = remoteLpad(remote_db)
    else:
        launchpad = LaunchPad()
    launchpad.reset('', require_password=False)
    
    #Queue  Configuration
    fworker      = FWorker(name = "Noodles_worker" )
    queueadapter = create_qadapter(queue_type, walltime, cpus_per_task, task_per_node)
    
    #Create WorkFlows
    fireworks_WF     = create_tasks(workflow)
    launchpad.add_wf(fireworks_WF) 

    
    rapidfire(launchpad, fworker, queueadapter, maxjobs_block,
              nlaunches = "infinite", reserve = "True", njobs_queue = maxjobs_queue )

    if remote_db:
        handlerPort.kill()    # close connections    

    

#====================<>===============================
@explicit_serialize
class NoodleTask(FireTaskBase):
    """
    """

    def run_task(self, fw_spec):
        self._load_params(fw_spec)

        args   = [get_value_from_spec(x) for x in self.args ]
        kwargs = dict([(k, get_value_from_db(x)) for k in self.kwargs.keys() ])
            
        r = run_python(self.func, args = self.args, kwargs = self.kwargs) 

        return FWAction(update_spec = {self.var_result : res}, stored_data = {self.var_result : res})

    def _load_params(self,d):
        self.var_result  = d['var_result']
        self.func        = d['func']
        self.args        = d['args']
        self.kwargs      = d['kwargs']

                
    @staticmethod        
    def get_value_from_spec(x):
        if isinstance(x,Ref_db):
           local_name, ref_db = x
           return fw_spec[ref_db]
        else:
            return x    
        
    def run_python(self):
        """
        Runs Any python function
        """
        toks = self.func.rsplit(".", 1)
        if len(toks) == 2:
            modname, funcname = toks
            mod = __import__(modname, globals(), locals(), [str(funcname)], 0)
            func = getattr(mod, funcname)
        else:
            #Handle built in functions.
            func = getattr(builtins, toks[0])


        return func(*self.args, **self.kwargs)
        
#====================<>===============================
def create_tasks(wf):
    """
    Translates the workflows generated by the Engine infrasctructure to a Fireworks Workflow.
    :param wf: Workflow container
    :type wf:    PromisedObject | Workflow
    :returns wf: Fireworks Workflow
    """

    workflow = get_workflow(wf)
    
    root_ref, nodes, links = workflow

    connections = fireworks_connections(links)
    fireworks   = []
    print("links:")
    print(links)
    for k in nodes.keys():
        print("Node:", k,nodes[k])
        n= create_noodle_task(k,nodes[k],links)
        fireworks.append(n)
        
    return WorkFlow(fireworks, connections)

def create_noodle_task(key, node, links):
    """
    Calculates the expression inside the node using the bound arguments. The variables
    corresponding to workflows are lookup from the database. Also, the node evaluation
    result is stored in the database.
    :param key: Unique node identifier  
    :param key: int
    :param node: Closure to execute remotely
    :type node: |FunctionNode|
    :param links: Dependencies between nodes
    :type  links: Dict
    """

    fun_node   = node.foo
    fun_module = fun_node.__module__
    fun_name   = fun_node.__name__
    fun_qual   = fun_module + '.' + fun_name
     
    #variable representing the result of computing this node, store in the db
    var_result   = 'var_{}'.format(key)
    args, kwargs = fireworks_dependencies(key,node,links)
    print(args,kwargs)
    task         = NoodleTask(func = fun_qual, args = args, kwargs = kwargs, var_result = var_result) 

    return Firework(task, fw_id = key)


def fireworks_dependencies(key,node,links):
    """
    :param key: Unique node identifier  
    :param key: int
    :param node: Closure to execute remotely
    :type node: |FunctionNode|
    :param links: Dependencies between nodes
    :type  links: Dict
    """
    args,kwargs  = [], {}
    bs = node.bound_args
    for p in bs.signature.parameters.values():
        name = p.name
        val  = bs.arguments[name]
        kind = p.kind
        if val != inspect._empty:
            kind_assignment(name, val, kind, args, kwargs)
        else:
            ref   = find_ref_from_links(name,key,links)

            thunk = Ref_db(name,ref)
            kind_assignment(name, thunk, kind, args, kwargs)
                        
    return args, kwargs 
            
def kind_assignment(name, val, kind, args, kwargs):
    """
    Based on the variable `signature.Parameter.kind` assigns `val` to either `args` or `kwargs`
    :param name: Variable name
    :type  name: `signature.Parameter.name`
    :param val: Value associated with the variable 
    :type  val: calculated during runtime
    :param kind: 
    :type  kind: `signature.Parameter.kind`
    """
    _kind_keywords = [inspect.Parameter.KEYWORD_ONLY, inspect.Parameter.VAR_KEYWORD]
    
    if any(map(lambda k: k==kind, _kind_keywords)):
        kwargs[name] = val
    else:
        args.append(val)

def find_ref_from_links(name,key,links):
    """
    :param name:  Variable name
    :type  name: `signature.Parameter.name`
    :param key : Node identifier
    :param key : Int
    """
    ref = None 
    for k in links.keys():
        ref = find_dependency_on_link(k,key,links) 
        if ref:
            continue

    if not ref:
        raise UndefinedDependency(name)
    
    return ref 
        
        
def find_dependency_on_link(k,key,links):
    """
    :param key : Node identifier
    :param key : Int

    """    
    for s in links[k]:
        FIXME!!!
        if s[0] == key:
            return k


def fireworks_connections(links):
    """
    Using the Noodles depencies returns a dictionary of Depencies for Fireworks.
    :param links: Dependencies between nodes
    :type  links: Dict
    """
    ds = {}
    for k in links.keys():
        ds[k] = get_children(links[k])

    return ds

def get_children(set_vars):
    """
    :param set_vars: set of pair (node_target, var_to_calculate) 
    :param set_vars: Set
    """
    return  [k[0] for k in set_vars]
        
    

#====================<>===============================
    
def create_qadapter(queue_type, walltime, cpus_per_task, task_per_node):
    
    return CommonAdapter(q_type=queue_type.upper(), qname= "Noodles_queue",
                         rocket_launch = "rlaunch singleshot --offline", ntasks = 1,
                         cpus_per_task = cpus_per_task, walltime = walltime, queue = None,
                         account = None, job_name = "Workflow", pre_rocket = None,
                         post_rocket  = None
           )



