

__all__ = ['run_fireworks', 'NoodleTask']

"""
Notes:
 *
"""

#================> Python Standard  and third-party <==========

from importlib import import_module
import sys
## ================ FireWorks modules  ==================
from fireworks                          import FireTaskBase,  Firework, FWorker, PyTask, ScriptTask, Workflow
from fireworks.queue.queue_launcher     import rapidfire, launch_rocket_to_queue
from fireworks.utilities.fw_serializers import FWSerializable
from fireworks.user_objects.queue_adapters.common_adapter import CommonAdapter

#=================> QMWorkflows module <=================
from qmworks.mongoConfig.remoteMongo import remoteLpad


#==================> Internal modules <==========
from .datamodel import *

#====================<>===============================
class UndefinedDependency(Exception):
    def __init__(self, var):
        self.msg = "Variable '{}' is not a regular value, neither has an assoicated workflow"
            .format(var)

    def __str__(self):
        return self.msg 

#====================<>===============================
    
Ref_db = namedtuple('Ref_db',('local_name','db_name'))

#====================<>===============================

#TODO: Remote Queue
def run_fireworks(workflow, remote_db = None,  queue_type = 'SLURM', walltime ='00:15:00', cpus_per_task = 1, task_per_node = 1, ntasks = 1, maxjobs_queue = 10):
    """
    Returns the result of evaluting the worflow using the `Offline <https://pythonhosted.org/FireWorks/offline_tutorial.html?highlight=offline>` mode of fireworks.
 
    :param workflow:  Workflow to compute
    :type  workflow:  namedTuple |Workflow| or |PromisedObject| 
    :param remote_host: Remote platform to run the calculations
    :type  remote_host: string
    """


     ## FireWorks Configuration
    if remote_db:
        launchpad, handlerPort = remoteLpad(remote_db)
    else:
        launchpad = LaunchPad()
    launchpad.reset('', require_password=False)
    
    #Queue  Configuration
    fworker      = FWorker(name = "Noodles_worker" )
    queueadapter = create_qadapter(queue_type, walltime, cpus_per_task, task_per_node)
    
    #Create WorkFlows
    fireworks_WF     = create_tasks(workflow)
    launchpad.add_wf(fireworks_WF) 

    
    rapidfire(launchpad, fworker, queueadapter, maxjobs_block,
              nlaunches = "infinite", reserve = "True", njobs_queue = maxjobs_queue )

    if remote_db:
        handlerPort.kill()    # close connections    

    

#====================<>===============================
class NoodleTask(FireTaskBase):
    """
    """

    _fw_name = "HDF5Task"    

    def run_task(self, fw_spec):
        if self.get("use_global_spec"):
            self._load_params(fw_spec)
        else:
            self._load_params(self)

        args   = [get_value_from_db(x) for x in self.arguments[0]]
        kwargs = dict([(k, get_value_from_db(x)) for k in self.arguments[0].keys()] )
            
        PyTask(self.fun, args = args, kwargs = kwargs, stored_data_varname = self.var_result) 
            
    def _load_params(self,d):
        self.var_result  = d['var_result']
        self.fun         = d['fun']
        self.arguments   = d['arguments']

        
        
    @staticmethod        
    def get_value_from_db(x):
        if isinstance(x,Ref_db):
           ###TODO      
        else:
            return x    
        

        
def create_tasks(wf):
    """
    Translates the workflows generated by the Engine infrasctructure to a Fireworks Workflow.
    :param wf: Workflow container
    :type wf:    PromisedObject | Workflow
    :returns wf: Fireworks Workflow
    """

    workflow = get_workflow(wf)
    
    root_ref, nodes, links = workflow

    connections = fireworks_connections(links)
    fireworks   = []
    for k in nodes.keys():
        n= create_noodle_task(k,nodes[k],links)
        fireworks.append(n)
        
    return WorkFlow(fireworks, connections)

def create_noodle_task(key, node, links):
    """
    Calculates the expression inside the node using the bound arguments. The variables
    corresponding to workflows are lookup from the database. Also, the node evaluation
    result is stored in the database.
    :param key: Unique node identifier  
    :param key: int
    :param node: Closure to execute remotely
    :type node: |FunctionNode|
    :param links: Dependencies between nodes
    :type  links: Dict
    """

    fun_node   = node.node
    fun_module = fun_node.module
    fun_name   = fun_node.name
    fun_qual   = fun_module + '.' + fun_name
     
    #variable representing the result of computing this node, store in the db
    var_result = 'var_{}'.format(key)

    # 
    args, kwargs = fireworks_dependencies(key,node,links)
    dict_spec    = create_dict_spec(args,kwargs,spec = {"_pass_job_info": True} )
    task         = NoodleTask(var_result = var_result, fun = fun_qual, arguments = (args, kwargs)) 

    return Firework(task, spec= dict_spec, fw_id = key)


def create_dict_spec(args,kwargs,spec = {}):
    """
    """
    for x in args:
        if isinstance(x,Ref_db):
            varname = 'var_ref'
        
    for k in kwargs.keys():
        

def fireworks_dependencies(key,node,links):
    """
    :param key: Unique node identifier  
    :param key: int
    :param node: Closure to execute remotely
    :type node: |FunctionNode|
    :param links: Dependencies between nodes
    :type  links: Dict
    """
    args,kwargs  = [], {}
    bs = node.bound_args
    for p in bs.signature.parameters.values():
        name = p.name
        val  = bs.arguments[name]
        kind = p.kind
        if val != inspect._empty:
            kind_assignment(name, val, kind, args, kwargs)
        else:
            ref   = find_ref_from_links(name,key,links)

            thunk = Ref_db(name,ref)
            kind_assignment(name, thunk, kind, args, kwargs)
                        
    return args, kwargs 
            
def kind_assignment(name, val, kind, args, kwargs):
    """
    Based on the variable `signature.Parameter.kind` assigns `val` to either `args` or `kwargs`
    :param name: Variable name
    :type  name: `signature.Parameter.name`
    :param val: Value associated with the variable 
    :type  val: calculated during runtime
    :param kind: 
    :type  kind: `signature.Parameter.kind`
    """
    _kind_keywords = [inspect.Parameter.KEYWORD_ONLY, inspect.Parameter.VAR_KEYWORD]
    
    if any(map(lambda k: k==kind, _kind_keywords)):
        kwargs[name] = val
    else:
        args.append(val)

def find_ref_from_links(name,key,links):
    """
    :param name:  Variable name
    :type  name: `signature.Parameter.name`
    :param key : Node identifier
    :param key : Int
    """
    ref = None 
    for k in links.keys():
        ref = find_dependency_on_link(k,key,links) 
        if ref:
            continue

    if not ref:
        raise UndefinedDependency(name)
    
    return ref 
        
        
def find_dependency_on_link(k,key,links):
    """
    :param key : Node identifier
    :param key : Int

    """    
    for s in links[k]:
        if s[0] == key:
            return k


def fireworks_connections(links):
    """
    Using the Noodles depencies returns a dictionary of Depencies for Fireworks.
    :param links: Dependencies between nodes
    :type  links: Dict
    """
    ds = {}
    for k in links.keys():
        ds[k] = get_children[k]

    return ds

def get_children(set_vars):
    """
    :param set_vars: set of pair (node_target, var_to_calculate) 
    :param set_vars: Set
    """
    return  [k for k,_var in set_vars]
        
    

#====================<>===============================
    
def create_qadapter(queue_type, walltime, cpus_per_task, task_per_node):
    
    return CommonAdapter(q_type=queue_type.upper(), qname= "Noodles_queue",
                         rocket_launch = "rlaunch singleshot --offline", ntasks = 1,
                         cpus_per_task = cpus_per_task, walltime = walltime, queue = None,
                         account = None, job_name = "Workflow", pre_rocket = None,
                         post_rocket  = None
           )



