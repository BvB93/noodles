

__all__ = ['run_fireworks']

#================> Python Standard  and third-party <==========

from importlib import import_module
import sys
## ================ FireWorks modules  ==================
from fireworks                          import FireTaskBase,  Firework, FWorker, PyTask, ScriptTask, Workflow
from fireworks.queue.queue_launcher     import rapidfire, launch_rocket_to_queue
from fireworks.utilities.fw_serializers import FWSerializable
from fireworks.user_objects.queue_adapters.common_adapter import CommonAdapter

#=================> QMWorkflows module <=================
from qmworks.mongoConfig.remoteMongo import remoteLpad


#==================> Internal modules <==========
from .datamodel import *

#====================<>===============================

#TODO: Remote Queue
def run_fireworks(workflow, remote_db = None,  queue_type = 'SLURM', walltime ='00:15:00', cpus_per_task = 1, task_per_node = 1, ntasks = 1, maxjobs_queue = 10):
    """
    Returns the result of evaluting the worflow using the `Offline <https://pythonhosted.org/FireWorks/offline_tutorial.html?highlight=offline>` mode of fireworks.
 
    :param workflow:  Workflow to compute
    :type  workflow:  namedTuple |Workflow| or |PromisedObject| 
    :param remote_host: Remote platform to run the calculations
    :type  remote_host: string
    """


     ## FireWorks Configuration
    if remote_db:
        launchpad, handlerPort = remoteLpad(remote_db)
    else:
        launchpad = LaunchPad()
    launchpad.reset('', require_password=False)
    
    #Queue  Configuration
    fworker      = FWorker(name = "Noodles_worker" )
    queueadapter = create_qadapter(queue_type, walltime, cpus_per_task, task_per_node)
    
    #Create WorkFlows
    fireworks_WF     = create_tasks(workflow)
    launchpad.add_wf(fireworks_WF) 

    
    rapidfire(launchpad, fworker, queueadapter, maxjobs_block,
              nlaunches = "infinite", reserve = "True", njobs_queue = maxjobs_queue )

    if remote_db:
        handlerPort.kill()    # close connections    


        

#====================<>===============================
def create_tasks(wf):
    """
    Translates the workflows generated by the Engine infrasctructure to a Fireworks Workflow.
    :param wf: Workflow container
    :type wf:    PromisedObject | Workflow
    :returns wf: Fireworks Workflow
    """

    workflow = get_workflow(wf)
    
    root_ref, nodes, links = workflow

    fireworks, connections = [], {}
    #Root Case
    node1    = nodes[root_ref]
    var_res  = 'var_{}'.format(root_ref)

    # prueba   = node1.foo(node1.bound_args.args, node1.bound_args.kwargs) 
    sys.exit()
    
    task     = PyTask(node1.foo, args = node1.bound_args.args, kwargs = node1.bound_args.kwargs, stored_data_varname = var_res) 
    fw1      = Firework(task, spec={"_pass_job_info": True}, fw_id = root_ref)
    nodes.pop(root_ref)

    fireworks.append(fw1)
    ## ith-case 

    return WorkFlow(fireworks, connections)





#====================<>===============================
    
def create_qadapter(queue_type, walltime, cpus_per_task, task_per_node):
    
    return CommonAdapter(q_type=queue_type.upper(), qname= "Noodles_queue",
                         rocket_launch = "rlaunch singleshot --offline", ntasks = 1,
                         cpus_per_task = cpus_per_task, walltime = walltime, queue = None,
                         account = None, job_name = "Workflow", pre_rocket = None,
                         post_rocket  = None
           )



